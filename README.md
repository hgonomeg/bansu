# Bansu

Server-side computation API for [Moorhen](https://github.com/moorhen-coot/Moorhen).

Currently it is mostly useful for running Acedrg computations on a server.

## Design

### Basic Description

The server allows you to spawn jobs using HTTP POST requests.
Each job gets assigned an ID (being an UUID) which can later be used
to trace the job's progress and to get the computation results.

After a job is spawned, you can trace job progress by listening on a WebSocket connection (documented below).

The ID of your job will be valid for the following amount of time:

```
2 * T
```

where `T` is the timeout value associated with a given job type.

The (current) default timeout for `Acedrg` is 2 minutes.

All data is deleted after job's ID becomes invalid i.e. expires.

### Security

All data (temporary directories with all artifacts) is automatically deleted after job's ID becomes invalid.
Whomever has the ID, can access your data. Treat the ID as both an identifier and a security token.

Keep in mind that not sharing your ID token does not prevent the server administrator from being able to see your data.
For maximum data security, you may want to run your own instance of Bansu.

For security reasons, the server also supports running jobs
in Docker containers which is the recommended thing to do.

Running jobs in a Docker container helps to isolate jobs from each other and the rest of the system.
This greatly reduces the potential impact of a successful exploitation of any vulnerabilities present in Acedrg and Servalcat.

### Configuration

The following environment variables control the behavior of the server:

* `TMPDIR` - can be used to specify location where jobs store temporary files
* `RUST_LOG` - sets the log level (like with most Rust programs)
* `BANSU_PORT` - sets the port to listen on (`8080` by default)
* `BANSU_ADDRESS` - sets the address to listen on (`127.0.0.1` by default)
* `BANSU_DOCKER` - enables Docker support and sets the name of the Docker image used for running jobs. If this variable is set, the server will refuse to run if the Docker configuration is invalid
* `BANSU_ACEDRG_TIMEOUT` - specifies timeout for Acedrg (in seconds) (`120` by default)

### API

The server exposes the following API:

### HTTP POST `/run_acedrg`

Creates `Acedrg` job.
Accepts the following JSON payload:

```json
{
    "smiles": "Your SMILES string",
    /// An array of additional arguments passed to acedrg
    /// Note: not all Acedrg arguments are currently available
    "commandline_args: ["-z", "--something"]
}
```

Replies with the following JSON:

```json
{
    /// Null on error
    "job_id": "UUID of your job",
    /// Null on success
    "error_message": "Error message if the request failed"
}
```

Returns:
* `201 Created` on success
* `400 Bad Request` on input validation error
* `500 Internal Server Error` on all other kinds of errors

### WEBSOCKET (HTTP GET) `/ws/{job_id}`

Opens a websocket connection which allows you to track the job's progress.
Progress reports have the following JSON format:

```json
{
    "status": "Pending | Finished | Failed",
    /// Will be null if the job is still pending, if it timed-out
    /// or the child process failed due to an I/O error
    "job_output": {
        "stdout": "A string",
        "stderr": "A string"
    },
    /// Only not-null if the job failed
    "failure_reason": "TimedOut | JobProcessError | SetupError"
}

```

Currently, progress messages are sent only when the connection opens and when the job either fails or completes successfully.

The connection ignores all messages sent to it (responds only to Ping messages).

Returns `404 Not Found` if the given `job_id` is not valid.


### HTTP GET `/get_cif/{job_id}`

For Acedrg jobs, streams the contents of the CIF file generated by Acedrg.

Returns:
* `200 OK` on success
* `404 Not Found` if the given `job_id` is not valid.
* `500 Internal Server Error` if the output file could not be read
* `400 Bad Request` if the given `job_id` does is not an `Acedrg` job or if the job is still pending

## Setup

### Build and run

In order to build Bansu, all you need is a Rust compiler.
Just use:

`$ cargo build -r`

No special compile-time dependencies are needed.

There is one optional runtime dependency: Docker.

The server manages docker containers (as described above in the security section).
It needs to have adequate permissions in order to do that.
The server uses the `bollard` crate to setup Docker connection using platform-dependent defaults (Unix pipe, Windows socket, fallback: HTTP).
Refer to [bollard documentation for more details](https://docs.rs/bollard/0.17.1/bollard/struct.Docker.html#method.connect_with_defaults).

If you do not want to make use of Docker support, make sure that `acedrg` and `servalcat` are available in the system path.

### Docker container setup

A `Dockerfile` is included to build a suitable Docker container image.

In order to build it:

1. Go to `docker/`
2. Run `docker build --pull --network host -t <name_of_your_image> -f FedoraDockerfile .`
3. Wait for the image to be built.

The image is based on Fedora but can be used on any distribution.

### Testing

In order to test Bansu, you can make use of the provided Node.JS script

## Name

The name is supposed to mean "Moorhen's Nest" in Japanese.

The kanji for "Moorhen" is "[鷭](https://jisho.org/word/%E9%B7%AD-1)".[^1]

The kanji for "nest" is "巣".

Combined together gives us:

<ruby>
<rb>鷭</rb>
<rt>ban</rt>
<rb>巣</rb>
<rt>su</rt>
</ruby>


[^1]: Note: A Japanese person will likely not recognize this character. It's rarely used.

## Todo

* Add max concurrent job limit
* Support for servalcat
* Think about API design for defining graph-like pipelines (if we ever need that)

use actix::prelude::*;
use actix_governor::{Governor, GovernorConfigBuilder};
use actix_web::{
    App, HttpRequest, HttpResponse, HttpServer, get,
    middleware::Condition,
    options, post,
    web::{self, Data},
};
use actix_ws::handle as ws_handle;
use std::{env, sync::Arc};
#[cfg(feature = "utoipa")]
use utoipa::OpenApi;
pub mod job;
use anyhow::Context;
use job::{
    JobEntry, JobManager, JobManagerVibeCheck, LookupJob, NewJob,
    job_handle::JobHandleConfiguration,
    job_runner::{OutputFileRequest, OutputKind, OutputRequestError},
    job_type::{JobSpawnError, acedrg::AcedrgJob},
};
pub mod messages;
use messages::*;
pub mod usage_statistics;
use usage_statistics::{
    FreshJobCommiter, RequestStatCommiter, RequestStatCommiterConsumer, finalize_job_statistics,
};
pub mod usage_statistics_entity;
pub mod utils;
pub mod ws_connection;
use ws_connection::WsConnection;
pub mod state;
use state::State;
use tokio::io::AsyncReadExt;

// use log::{info,warn,error,debug};

#[cfg(feature = "utoipa")]
#[derive(OpenApi)]
#[openapi(
    info(
        title = "Bansu",
        description = "Server-side computation API for Moorhen"
    ),
    paths(get_cif, run_acedrg, job_ws, vibe_check)
)]
struct ApiDoc;

#[cfg_attr(feature = "utoipa", utoipa::path(
    description = "For Acedrg jobs, streams the contents of the CIF file generated by Acedrg.",
    // Let's do this in responses instead?
    // request_body(content_type = "text/plain", description = "Streamed CIF file contents. Present when successful."),
    responses(
        (status = 200, description = "Success. Streams CIF file contents", content_type = "text/plain"),
        (status = 404, description = "The given `job_id` is not valid"),
        (status = 400, description = "The given `job_id` does not correspond to an `Acedrg` job or the job is still pending (or queued)"),
        (status = 500, description = "Output file could not be read or other error"),
    ),
    params(
        ("job_id", description = "Job ID")
    )
))]
#[get("/get_cif/{job_id}")]
async fn get_cif(
    path: web::Path<JobId>,
    job_manager: web::Data<Addr<JobManager>>,
    state: web::Data<State>,
    http_req: HttpRequest,
) -> HttpResponse {
    let stats_commiter_opt = RequestStatCommiter::with_state_and_request(&state, &http_req);
    let job_id = path.into_inner();

    let Some(job_entry) = job_manager.send(LookupJob(job_id.clone())).await.unwrap() else {
        log::error!("/get_cif/{} - Job not found", job_id);
        stats_commiter_opt
            .commit_failed(&job_manager, Some("Job not found".into()))
            .await;
        return HttpResponse::NotFound().finish();
    };

    let JobEntry::Spawned(job) = job_entry else {
        log::error!("/get_cif/{} - Job is still queued.", job_id);
        stats_commiter_opt
            .commit_failed(&job_manager, Some("Job is still queued".into()))
            .await;
        return HttpResponse::BadRequest().finish();
    };

    let file_res = job
        .send(OutputFileRequest {
            kind: OutputKind::CIF,
        })
        .await
        .unwrap();

    match file_res {
        Err(OutputRequestError::IOError(e)) => {
            let error_msg = format!("Could not open output - {}", &e);
            stats_commiter_opt
                .commit_failed(&job_manager, Some(error_msg.clone()))
                .await;
            log::error!("/get_cif/{} - {}", job_id, &error_msg);
            HttpResponse::InternalServerError().body(e.to_string())
        }
        Err(OutputRequestError::JobStillPending) => {
            log::warn!("/get_cif/{} - Job is still pending.", job_id);
            stats_commiter_opt
                .commit_failed(&job_manager, Some("Job is still pending".into()))
                .await;
            HttpResponse::BadRequest().finish()
        }
        Err(OutputRequestError::OutputKindNotSupported) => {
            log::error!("/get_cif/{} - This job does not support CIF output", job_id);
            stats_commiter_opt
                .commit_failed(
                    &job_manager,
                    Some("This job does not support CIF output".into()),
                )
                .await;
            HttpResponse::BadRequest().finish()
        }
        Ok(mut file) => {
            let (tx, rx) = tokio::sync::mpsc::channel::<Result<web::Bytes, std::io::Error>>(64);
            actix_rt::spawn(async move {
                log::info!("/get_cif/{} - Replying with CIF file", job_id);
                loop {
                    let mut buf = web::BytesMut::with_capacity(65536);
                    let read_res = file.read_buf(&mut buf).await;
                    match read_res {
                        Ok(n) => {
                            if n == 0 {
                                // end of file
                                break;
                            } else {
                                let _ = tx.send(Ok(buf.into())).await;
                            }
                        }
                        Err(e) => {
                            let _ = tx.send(Err(e)).await;
                            break;
                        }
                    }
                }
            });

            stats_commiter_opt.commit_successful(&job_manager).await;
            HttpResponse::Ok().streaming(tokio_stream::wrappers::ReceiverStream::new(rx))
        }
    }
}

#[cfg_attr(feature = "utoipa", utoipa::path(
    description = r#"Opens a WebSocket connection which allows you to track the job's progress.
Progress messages are sent in the following scenarios:

* When the connection gets established
* When the job status / `job_output` get updated
* Periodically, with interval specified in server configuration (useful for estimating how long it may take for a queued job to be processed)

Connection gets automatically closed if the job fails or completes.

For queued jobs which could not have been started, listening on a WebSocket also lets you know why it failed (including input validation failure and all oher errors).

The connection ignores all messages sent to it (responds only to Ping messages).
"#,
    responses(
        (status = 101, description = "Opens up WebSocket connection", 
            headers(
                ("Connection" = String, description = "Upgrade"), 
                ("Upgrade" = String, description = "websocket")
            )
        ),
        (status = 404, description = "The given `job_id` is not valid")

    ),
    request_body(content = WsJobDataUpdate, description = "This is the format of progress reports sent through the WebSocket."),
    params(
        ("job_id", description = "Job ID")
    )
))]
#[get("/ws/{job_id}")]
async fn job_ws(
    path: web::Path<JobId>,
    req: HttpRequest,
    state: web::Data<State>,
    payload: web::Payload,
    job_manager: web::Data<Addr<JobManager>>,
) -> Result<HttpResponse, actix_web::Error> {
    let stats_commiter_opt = RequestStatCommiter::with_state_and_request(&state, &req);
    let job_id = path.into_inner();
    let Some(job_entry) = job_manager
        .send(LookupJob(job_id.clone()))
        .await
        .ok()
        .flatten()
    else {
        log::error!("/ws/{} - Job not found", job_id);
        stats_commiter_opt
            .commit_failed(&job_manager, Some("Job not found".into()))
            .await;
        return Ok(HttpResponse::NotFound().finish());
    };
    let jm = job_manager.get_ref().clone();
    let job_opt = match job_entry {
        JobEntry::Spawned(job) => Some(job),
        JobEntry::Queued(_queue_pos) => None,
    };
    let (response, session, msg_stream) = ws_handle(&req, payload)?;
    WsConnection::new(jm, job_opt, job_id, session, msg_stream);
    stats_commiter_opt.commit_successful(&job_manager).await;
    Ok(response)
}

#[options("/run_acedrg")]
// This is here due to CORS necessities
// Do we want to add this to utoipa?
async fn run_acedrg_preflight(_req: HttpRequest) -> HttpResponse {
    // if let Some(val) = req.headers().get("Access-Control-Request-Method") {
    //     if val.to_str().unwrap_or("") != "POST" {
    //         HttpResponse::BadRequest()
    //     }
    // }
    // if let Some(val) = req.headers().get("Access-Control-Request-Headers") {
    //     match val.to_str().unwrap_or("") {
    //         "content-type" | "Content-Type" => {

    //         }
    //         _ => {

    //         }
    //     }
    // }
    // Anything other than 404 is already nice
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods/OPTIONS#preflighted_requests_in_cors
    HttpResponse::Ok()
        .insert_header(("Allow", "OPTIONS, POST"))
        .insert_header(("Access-Control-Allow-Headers", "content-type"))
        // should also be set by nginx and therefore let's not put it here, not to cause a collision
        // .insert_header(("Access-Control-Allow-Origin", "*"))
        // The above permissions may be cached for 604,800 seconds (1 week)
        .insert_header(("Access-Control-Max-Age", "604800"))
        .finish()
}

#[cfg_attr(feature = "utoipa", utoipa::path(
    description = "Creates `Acedrg` job.",
    // this gets confused with input for the POST request
    // request_body = JobSpawnReply,
    // There seems to be no better way than to specify 'body' multiple times.
    responses(
        (status = 201, description = "Success (job spawned)", body = JobSpawnReply),
        (status = 202, description = "Success (job queued)", body = JobSpawnReply),
        (status = 400, description = "Input validation error", body = JobSpawnReply),
        (status = 503, description = "Server is currently at capacity and is unable to handle your request", body = JobSpawnReply),
        (status = 500, description = "Other error", body = JobSpawnReply),
    ),
))]
#[post("/run_acedrg")]
async fn run_acedrg(
    args: web::Json<AcedrgArgs>,
    job_manager: web::Data<Addr<JobManager>>,
) -> HttpResponse {
    let args = args.into_inner();
    let jo = Arc::from(AcedrgJob { args });

    match job_manager.send(NewJob(jo)).await.unwrap() {
        Ok(resp) => match resp.entry {
            JobEntry::Spawned(_job) => HttpResponse::Created().json(JobSpawnReply {
                job_id: Some(resp.id),
                error_message: None,
                queue_position: None,
            }),
            JobEntry::Queued(queue_pos) => HttpResponse::Accepted().json(JobSpawnReply {
                job_id: Some(resp.id),
                error_message: None,
                queue_position: Some(queue_pos),
            }),
        },
        Err(JobSpawnError::InputValidation(e)) => {
            log::warn!("/run_acedrg - Could not create job: {:#}", &e);
            HttpResponse::BadRequest().json(JobSpawnReply {
                job_id: None,
                error_message: Some(format!("{:#}", e)),
                queue_position: None,
            })
        }
        Err(JobSpawnError::TooManyJobs) => {
            log::warn!("/run_acedrg - Could not create job: Too many jobs");
            HttpResponse::ServiceUnavailable().json(JobSpawnReply {
                job_id: None,
                error_message: Some("Server is at capacity. Please try again later.".to_string()),
                queue_position: None,
            })
        }
        Err(JobSpawnError::Other(e)) => {
            log::error!("/run_acedrg - Could not create job: {:#}", &e);
            HttpResponse::InternalServerError().json(JobSpawnReply {
                job_id: None,
                error_message: Some(format!("{:#}", e)),
                queue_position: None,
            })
        }
    }
}

#[cfg_attr(
    feature = "utoipa",
    utoipa::path(description = "Health check endpoint.",
    responses(
        (status = 200, description = "Server is up and running", body = VibeCheckResponse),
        // (status = 500, description = "Server is not running properly")
    ),
))]
#[get("/vibe_check")]
async fn vibe_check(
    job_manager: web::Data<Addr<JobManager>>,
    state: web::Data<State>,
    http_req: HttpRequest,
) -> HttpResponse {
    let stats_commiter_opt = RequestStatCommiter::with_state_and_request(&state, &http_req);
    log::info!("/vibe_check - Replying to vibe check request");
    // We can safely unwrap because JobManagerVibeCheck does not fail
    let jmvc = job_manager.send(JobManagerVibeCheck).await.unwrap();
    if let Some(commiter) = stats_commiter_opt {
        commiter
            .commit_successful(
                jmvc.queue_length.unwrap_or(0) as i64,
                jmvc.active_jobs as i64,
            )
            .await;
    }
    let response = VibeCheckResponse::build(jmvc, &state);
    HttpResponse::Ok().json(response)
}

#[actix_web::main]
async fn main() -> anyhow::Result<()> {
    eprintln!(
        "Bansu Server, v{} \n\nAuthors: {}\nLicense: {}\nCopyright (C) 2024 - 2025, Global Phasing Ltd.",
        env!("CARGO_PKG_VERSION"),
        env!("CARGO_PKG_AUTHORS"),
        env!("CARGO_PKG_LICENSE")
    );

    simple_logger::SimpleLogger::new().env().init().unwrap();

    let addr = env::var("BANSU_ADDRESS").unwrap_or("127.0.0.1".to_string());
    let port: u16 = env::var("BANSU_PORT")
        .ok()
        .map(|port_str| port_str.parse::<u16>())
        .transpose()
        .with_context(|| "Could not parse port number")?
        .unwrap_or(8080);

    let docker_configuration = if let Ok(docker_image_name) = env::var("BANSU_DOCKER") {
        log::info!("Testing Docker configuration...");
        if let Err(e) = utils::test_docker(&docker_image_name).await {
            log::error!("Docker test failed - {:#}. Disabling Docker support.", e);
            None
        } else {
            log::info!("Docker test successful.");
            Some(docker_image_name)
        }
    } else {
        log::info!("Docker configuration was not provided.");
        None
    };

    if docker_configuration.is_none() {
        if env::var("BANSU_DISALLOW_DOCKERLESS").is_ok() {
            let e = anyhow::anyhow!(
                "No (valid) Docker configuration was provided and BANSU_DISALLOW_DOCKERLESS is set. Refusing to continue."
            );
            log::error!("{}", &e);
            return Err(e);
        }
        log::info!("Testing environment configuration...");
        if let Err(e) = utils::test_dockerless().await {
            log::error!(
                "Environment test failed: {} Refusing to continue without usable 'acedrg' and 'servalcat'.",
                &e
            );
            return Err(e);
        }
    }

    if docker_configuration.is_some() {
        log::info!("Starting with Docker support.");
    } else {
        log::info!("Starting without Docker support.");
    }

    let max_queue_length = env::var("BANSU_MAX_JOB_QUEUE_LENGTH")
        .ok()
        .map(|port_str| port_str.parse::<usize>())
        .transpose()
        .with_context(|| "Could not parse max job queue length number")?
        .map(|raw_num| if raw_num == 0 { None } else { Some(raw_num) })
        .unwrap_or(Some(20));

    let max_concurrent_jobs = env::var("BANSU_MAX_CONCURRENT_JOBS")
        .ok()
        .map(|port_str| port_str.parse::<usize>())
        .transpose()
        .with_context(|| "Could not parse max concurrent job number")?
        .map(|raw_num| if raw_num == 0 { None } else { Some(raw_num) })
        .unwrap_or(Some(20));

    log::info!(
        "Max concurrent job limit: {}. Max job queue length: {}.",
        match max_concurrent_jobs.as_ref() {
            Some(v) => v.to_string(),
            None => "No limit".to_string(),
        },
        match max_queue_length.as_ref() {
            Some(v) => v.to_string(),
            None => "No limit".to_string(),
        }
    );

    let usage_stats_db = match env::var("BANSU_USAGE_STATS_DB").ok() {
        Some(db_url) => Some(
            sea_orm::Database::connect(db_url)
                .await
                .with_context(|| "Could not connect to usage statistics database.")?,
        ),
        None => {
            log::info!("Usage statistics database configuration not provided.");
            None
        }
    };

    let state_data = Data::new(State::new(max_concurrent_jobs, usage_stats_db));
    let job_manager = JobManager::new(
        max_concurrent_jobs,
        max_queue_length,
        JobHandleConfiguration {
            docker_image: docker_configuration,
        },
    )
    .start();

    let governor_conf = if env::var("BANSU_DISABLE_RATELIMIT").is_err() {
        let burst_size = env::var("BANSU_RATELIMIT_BURST_SIZE")
            .ok()
            .map(|port_str| port_str.parse::<u32>())
            .transpose()
            .with_context(|| "Could not parse rate-limiter burst size")?
            .unwrap_or(45);

        let sec_per_rq = env::var("BANSU_RATELIMIT_SECONDS_PER_REQUEST")
            .ok()
            .map(|port_str| port_str.parse::<u64>())
            .transpose()
            .with_context(|| "Could not parse rate-limiter seconds per request")?
            .unwrap_or(10);

        log::info!(
            "Rate-limiter configuration: burst_size={} seconds_per_request={}",
            burst_size,
            sec_per_rq
        );

        GovernorConfigBuilder::default()
            .seconds_per_request(sec_per_rq)
            .burst_size(burst_size)
            .finish()
            .with_context(|| "Invalid rate limiter configuration")?
    } else {
        log::info!("Rate-limiter disabled");
        GovernorConfigBuilder::default()
            // just in case
            .permissive(true)
            .finish()
            .unwrap()
    };

    #[derive(Clone, Default)]
    struct ServerPathConfig {
        #[cfg(feature = "utoipa")]
        disable_apidoc: bool,
        base_url: Option<String>,
    }

    let mut config = ServerPathConfig::default();

    #[cfg(feature = "utoipa")]
    if !env::var("BANSU_DISABLE_APIDOC").is_ok() {
        log::info!("Enabling OpenAPI documentation.");
    } else {
        config.disable_apidoc = true;
        log::info!("OpenAPI documentation disabled.");
    }
    #[cfg(not(feature = "utoipa"))]
    log::info!("OpenAPI documentation disabled at compile-time.");

    if let Ok(base_url) = env::var("BANSU_BASE_URL") {
        log::info!("Enabling base url: {}", &base_url);
        config.base_url = Some(base_url);
    } else {
        log::info!("No base url defined. Starting on global scope.");
    }

    #[cfg(feature = "utoipa")]
    async fn apidoc_json(api: Data<utoipa::openapi::OpenApi>) -> HttpResponse {
        HttpResponse::Ok().json(api)
    }

    #[cfg(feature = "utoipa")]
    async fn apidoc_yaml(api: Data<utoipa::openapi::OpenApi>) -> HttpResponse {
        match api.as_ref().to_yaml() {
            Ok(yaml) => HttpResponse::Ok().body(yaml),
            Err(e) => {
                let err_msg = format!("{}", e);
                log::error!("/api-docs/openapi.yaml - {}", err_msg);
                HttpResponse::InternalServerError().body(format!("{}", err_msg))
            }
        }
    }

    fn configure_paths(cfg: &mut actix_web::web::ServiceConfig, pcfg: ServerPathConfig) {
        fn configure_content(
            cfg: &mut actix_web::web::ServiceConfig,
            #[cfg(feature = "utoipa")] apidoc: Option<utoipa::openapi::OpenApi>,
            #[cfg(not(feature = "utoipa"))] _apidoc: (),
        ) {
            cfg.service(vibe_check)
                .service(run_acedrg)
                .service(run_acedrg_preflight)
                .service(get_cif)
                .service(job_ws);

            #[cfg(feature = "utoipa")]
            if let Some(apidoc) = apidoc {
                cfg.service(
                    // Do we want/need this scope?
                    web::scope("/api-docs")
                        .app_data(Data::new(apidoc.clone()))
                        .route("/openapi.json", web::get().to(apidoc_json))
                        .route("/openapi.yaml", web::get().to(apidoc_yaml)),
                );
            }
        }

        #[cfg(feature = "utoipa")]
        let apidoc = if pcfg.disable_apidoc {
            None
        } else {
            Some(ApiDoc::openapi())
        };
        #[cfg(not(feature = "utoipa"))]
        let apidoc = ();

        match pcfg.base_url {
            Some(base_url) => {
                cfg.service(web::scope(&base_url).configure(|cfg| configure_content(cfg, apidoc)));
            }
            None => {
                cfg.configure(|cfg| configure_content(cfg, apidoc));
            }
        }
    }

    log::info!("Initializing HTTP server...");
    Ok(HttpServer::new(move || {
        let pconfig = config.clone();
        App::new()
            .wrap(Condition::new(
                env::var("BANSU_DISABLE_RATELIMIT").is_err(),
                Governor::new(&governor_conf),
            ))
            .app_data(Data::new(job_manager.clone()))
            .app_data(state_data.clone())
            .configure(|cfg: &mut actix_web::web::ServiceConfig| configure_paths(cfg, pconfig))
    })
    .bind((addr, port))?
    .run()
    .await?)
}
